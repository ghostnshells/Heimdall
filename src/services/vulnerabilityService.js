// Vulnerability Service - Aggregates data from multiple sources
// Sources: NVD (National Vulnerability Database), CISA KEV (Known Exploited Vulnerabilities), Vendor Feeds
// All data is real and verifiable through official sources

import { fetchVulnerabilitiesForAsset, getMostRecentDate } from './nvdApi';
import { searchCISAForAsset } from './cisaApi';
import { fetchVendorAdvisories } from './vendorFeeds';
import { ASSETS } from '../data/assets';

/**
 * Sort vulnerabilities by most recent date (either published or lastModified)
 * Most recent first
 */
const sortByMostRecentDate = (vulnerabilities) => {
    return [...vulnerabilities].sort((a, b) => {
        const aDate = getMostRecentDate(a);
        const bDate = getMostRecentDate(b);
        return bDate - aDate;
    });
};

// Detect if we have a backend API available
// Supports: Express server (VITE_API_URL), Vercel Serverless Functions (VITE_USE_BACKEND),
// or direct API calls via rewrites as fallback
const EXTERNAL_API_URL = import.meta.env.VITE_API_URL;
const HAS_BACKEND = !!EXTERNAL_API_URL || import.meta.env.VITE_USE_BACKEND === 'true' || import.meta.env.PROD;
const BACKEND_API = EXTERNAL_API_URL
    ? `${EXTERNAL_API_URL}/api/vulnerabilities`
    : '/api/vulnerabilities';

// Cache configuration
const CACHE_VERSION = 'v2'; // Increment this to invalidate all caches
const CACHE_KEY_PREFIX = `heimdall_vuln_cache_${CACHE_VERSION}_`;
const CACHE_DURATION = HAS_BACKEND ? 5 * 60 * 1000 : 30 * 60 * 1000; // 5 min with backend (it handles caching), 30 min for direct API calls

// Time range order from shortest to longest (for comparison)
// NVD API has a 120-day max limit on date ranges, so we use 119 to be safe
const TIME_RANGE_ORDER = ['24h', '7d', '30d', '90d', '119d'];

// In-memory cache - persists across time range switches within the same session
// This is the primary cache; localStorage is secondary (for persistence across page reloads)
const memoryCache = new Map();

/**
 * Get the duration in days for a time range (used for comparison)
 */
const getTimeRangeDays = (timeRange) => {
    switch (timeRange) {
        case '24h': return 1;
        case '7d': return 7;
        case '30d': return 30;
        case '90d': return 90;
        case '119d': return 119;
        default: return 7;
    }
};

/**
 * Check if targetRange is shorter than or equal to sourceRange
 */
const isRangeShorterOrEqual = (targetRange, sourceRange) => {
    return getTimeRangeDays(targetRange) <= getTimeRangeDays(sourceRange);
};

/**
 * Get cache key for specific time range
 */
const getCacheKey = (timeRange) => `${CACHE_KEY_PREFIX}${timeRange}`;

/**
 * Get cached data if valid for specific time range
 * Checks in-memory cache first, then localStorage
 */
const getCachedData = (timeRange) => {
    // Check in-memory cache first (faster and no size limits)
    const memCached = memoryCache.get(timeRange);
    if (memCached) {
        const isExpired = Date.now() - memCached.timestamp > CACHE_DURATION;
        if (!isExpired) {
            console.log(`Using in-memory cache for ${timeRange}`);
            return memCached.data;
        } else {
            memoryCache.delete(timeRange);
        }
    }

    // Fall back to localStorage
    try {
        const cacheKey = getCacheKey(timeRange);
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;

        const { timestamp, data } = JSON.parse(cached);
        const isExpired = Date.now() - timestamp > CACHE_DURATION;

        if (isExpired) {
            localStorage.removeItem(cacheKey);
            return null;
        }

        // Restore to in-memory cache for faster subsequent access
        memoryCache.set(timeRange, { timestamp, data });
        return data;
    } catch (error) {
        console.error('Error reading cache:', error);
        return null;
    }
};

/**
 * Save data to cache for specific time range
 * Saves to both in-memory cache and localStorage
 */
const setCachedData = (data, timeRange) => {
    const timestamp = Date.now();

    // Always save to in-memory cache (no size limits)
    memoryCache.set(timeRange, { timestamp, data });

    // Try to save to localStorage for persistence across page reloads
    try {
        const cacheKey = getCacheKey(timeRange);
        localStorage.setItem(cacheKey, JSON.stringify({
            timestamp,
            data
        }));
    } catch (error) {
        // localStorage might fail due to quota exceeded, but in-memory cache still works
        console.warn(`localStorage cache failed for ${timeRange} (quota exceeded?), using in-memory cache only:`, error.message);
    }
};

/**
 * Find cached data from a larger time range that we can filter down
 * Checks both in-memory and localStorage caches
 */
const findLargerCachedData = (targetRange) => {
    // Get all time ranges that are larger than the target
    const targetDays = getTimeRangeDays(targetRange);

    for (const range of TIME_RANGE_ORDER) {
        if (getTimeRangeDays(range) > targetDays) {
            const cached = getCachedData(range);
            if (cached) {
                console.log(`Found cached data from ${range} range that can be filtered to ${targetRange}`);
                return { data: cached, sourceRange: range };
            }
        }
    }
    return null;
};

/**
 * Filter vulnerabilities to only include those within the target time range
 * Uses max(published, lastModified) for sorting - most recent first
 */
const filterVulnerabilitiesToRange = (data, targetRange) => {
    const { startDate, endDate } = getDateRange(targetRange);
    const startTime = startDate.getTime();
    const endTime = endDate.getTime();

    const filteredByAsset = {};
    const filteredAll = [];

    Object.entries(data.byAsset).forEach(([assetId, vulns]) => {
        const filteredVulns = vulns.filter(vuln => {
            const publishedDate = vuln.published ? new Date(vuln.published).getTime() : 0;
            // Only check published date - NVD's lastModified reflects metadata changes,
            // not meaningful vulnerability updates, which caused misleading dates
            return publishedDate >= startTime && publishedDate <= endTime;
        });
        // Sort per-asset vulnerabilities by most recent date
        const sortedFilteredVulns = sortByMostRecentDate(filteredVulns);
        filteredByAsset[assetId] = sortedFilteredVulns;
        filteredAll.push(...sortedFilteredVulns);
    });

    return {
        byAsset: filteredByAsset,
        all: sortByMostRecentDate(filteredAll),
        fetchedAt: data.fetchedAt,
        timeRange: targetRange,
        source: data.source,
        filteredFrom: data.timeRange
    };
};

/**
 * Calculate date range based on time period selection
 * Note: NVD API has a 120-day max limit on date range queries, so we use 119 to be safe
 */
export const getDateRange = (timeRange) => {
    const endDate = new Date();
    let startDate = new Date();

    switch (timeRange) {
        case '24h':
            startDate.setHours(startDate.getHours() - 24);
            break;
        case '7d':
            startDate.setDate(startDate.getDate() - 7);
            break;
        case '30d':
            startDate.setDate(startDate.getDate() - 30);
            break;
        case '90d':
            startDate.setDate(startDate.getDate() - 90);
            break;
        case '119d':
            startDate.setDate(startDate.getDate() - 119);
            break;
        default:
            startDate.setDate(startDate.getDate() - 7);
    }

    return { startDate, endDate };
};

/**
 * Fetch vulnerabilities from backend API (production mode)
 * Backend handles caching and rate limiting
 */
const fetchFromBackend = async (timeRange) => {
    console.log(`[VulnService] Fetching from backend API for ${timeRange}`);
    console.log(`[VulnService] Backend API URL: ${BACKEND_API}`);

    try {
        const response = await fetch(`${BACKEND_API}?timeRange=${timeRange}`);
        console.log(`[VulnService] Response received:`, response.status, response.ok);

        if (!response.ok) {
            throw new Error(`Backend API error: ${response.status}`);
        }

        const result = await response.json();
        console.log(`[VulnService] Data received:`, {
            success: result.success,
            vulnCount: result.data?.all?.length || 0,
            hasData: !!result.data
        });

        if (!result.success) {
            throw new Error(result.message || 'Backend fetch failed');
        }

        // Transform backend data to match frontend expected format
        const data = result.data;

        const transformed = {
            vulnerabilities: data.byAsset || {},
            allVulnerabilities: data.all || [],
            totalCount: data.all?.length || 0,
            criticalCount: (data.all || []).filter(v => v.severity === 'CRITICAL').length,
            highCount: (data.all || []).filter(v => v.severity === 'HIGH').length,
            mediumCount: (data.all || []).filter(v => v.severity === 'MEDIUM').length,
            lowCount: (data.all || []).filter(v => v.severity === 'LOW').length,
            timestamp: data.fetchedAt || new Date().toISOString(),
            source: 'Backend (Cached)',
            timeRange,
            cacheInfo: result.cacheInfo
        };

        console.log(`[VulnService] Transformed data:`, {
            totalCount: transformed.totalCount,
            assetCount: Object.keys(transformed.vulnerabilities).length
        });

        return transformed;
    } catch (error) {
        console.error(`[VulnService] Error in fetchFromBackend:`, error);
        throw error;
    }
};

/**
 * Fetch all vulnerabilities for all monitored assets from NVD API
 * @param {string} timeRange - Time range selection
 * @param {Function} onProgress - Progress callback (current, total, assetName)
 * @param {boolean} forceRefresh - Bypass cache
 * @returns {Promise<Object>} Vulnerability data
 */
export const fetchAllVulnerabilities = async (timeRange = '7d', onProgress = null, forceRefresh = false) => {
    // If a backend API URL is configured, fetch from backend (which handles caching)
    if (HAS_BACKEND) {
        try {
            // Still check local cache to avoid unnecessary requests
            if (!forceRefresh) {
                const cached = getCachedData(timeRange);
                if (cached) {
                    console.log(`Using local cache for ${timeRange}`);
                    return cached;
                }
            }

            if (onProgress) onProgress(0, 1, 'Fetching from server...');
            const data = await fetchFromBackend(timeRange);
            setCachedData(data, timeRange);
            if (onProgress) onProgress(1, 1, 'Complete');
            return data;
        } catch (error) {
            console.error('Backend fetch failed:', error);
            // Fall back to cached data if available
            const cached = getCachedData(timeRange);
            if (cached) return cached;
            throw error;
        }
    }

    // Direct API calls mode (used on Vercel/static hosting and in development)
    // Check cache first (cache is now keyed by time range)
    if (!forceRefresh) {
        // 1. Check exact cache for this time range
        const cached = getCachedData(timeRange);
        if (cached) {
            console.log(`Using cached vulnerability data from NVD for ${timeRange}`);
            return cached;
        }

        // 2. Check if we have cached data from a larger time range we can filter
        const largerCache = findLargerCachedData(timeRange);
        if (largerCache) {
            console.log(`Filtering cached ${largerCache.sourceRange} data to ${timeRange} (no API call needed)`);
            const filteredData = filterVulnerabilitiesToRange(largerCache.data, timeRange);
            // Cache the filtered result for faster future access
            setCachedData(filteredData, timeRange);
            return filteredData;
        }
    }

    console.log(`[VulnService] Fetching vulnerabilities for time range: ${timeRange}`);
    const { startDate, endDate } = getDateRange(timeRange);
    console.log(`[VulnService] Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);
    const vulnerabilities = {};
    const allVulns = [];

    for (let i = 0; i < ASSETS.length; i++) {
        const asset = ASSETS[i];

        if (onProgress) {
            onProgress(i, ASSETS.length, asset.name);
        }

        try {
            // Fetch from NVD
            const nvdVulns = await fetchVulnerabilitiesForAsset(asset, startDate, endDate);

            // Fetch from CISA KEV (known exploited vulnerabilities)
            let cisaVulns = [];
            try {
                cisaVulns = await searchCISAForAsset(asset, startDate, endDate);
            } catch (cisaError) {
                console.warn(`CISA fetch failed for ${asset.name}:`, cisaError);
            }

            // Fetch vendor-specific advisories
            let vendorVulns = [];
            try {
                vendorVulns = await fetchVendorAdvisories(asset, startDate, endDate);
            } catch (vendorError) {
                console.warn(`Vendor feed failed for ${asset.name}:`, vendorError);
            }

            // Merge and deduplicate (NVD takes precedence, but merge CISA data if available)
            const cisaVulnMap = new Map(cisaVulns.map(v => [v.id, v]));
            const mergedVulns = nvdVulns.map(vuln => {
                const cisaVuln = cisaVulnMap.get(vuln.id);
                return {
                    ...vuln,
                    activelyExploited: cisaVuln ? true : vuln.activelyExploited,
                    cisaData: cisaVuln?.cisaData || vuln.cisaData
                };
            });

            // Add CISA-only vulns (not in NVD results)
            const nvdCveIds = new Set(nvdVulns.map(v => v.id));
            const cisaOnlyVulns = cisaVulns.filter(v => !nvdCveIds.has(v.id));
            mergedVulns.push(...cisaOnlyVulns);

            // Add vendor advisories (these may not have CVE IDs)
            mergedVulns.push(...vendorVulns);

            // Sort vulnerabilities for this asset by most recent date (published or lastModified)
            const sortedMergedVulns = sortByMostRecentDate(mergedVulns);

            vulnerabilities[asset.id] = sortedMergedVulns;
            allVulns.push(...sortedMergedVulns);
            console.log(`Fetched ${mergedVulns.length} vulnerabilities for ${asset.name} (NVD: ${nvdVulns.length}, CISA: ${cisaVulns.length})`);
        } catch (error) {
            console.error(`Error fetching vulns for ${asset.name}:`, error);
            vulnerabilities[asset.id] = [];
        }
    }

    const result = {
        byAsset: vulnerabilities,
        all: sortByMostRecentDate(allVulns), // Sort by max(published, lastModified) - most recent first
        fetchedAt: new Date().toISOString(),
        timeRange,
        source: 'NVD'
    };

    console.log(`[VulnService] TOTAL: ${allVulns.length} vulnerabilities fetched for ${timeRange}`);
    console.log(`[VulnService] By asset counts:`, Object.entries(vulnerabilities).map(([id, v]) => `${id}: ${v.length}`).join(', '));

    // Cache the results with time range
    setCachedData(result, timeRange);

    return result;
};

/**
 * Fetch vulnerabilities for a single asset
 */
export const fetchAssetVulnerabilities = async (assetId, timeRange = '7d') => {
    const asset = ASSETS.find(a => a.id === assetId);
    if (!asset) {
        throw new Error(`Asset not found: ${assetId}`);
    }

    const { startDate, endDate } = getDateRange(timeRange);
    return fetchVulnerabilitiesForAsset(asset, startDate, endDate);
};

/**
 * Get summary statistics for vulnerabilities
 */
export const getVulnerabilityStats = (vulnerabilities) => {
    if (!vulnerabilities?.all) {
        return {
            total: 0,
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            unknown: 0,
            assetsAffected: 0
        };
    }

    const stats = {
        total: vulnerabilities.all.length,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        unknown: 0,
        assetsAffected: 0
    };

    vulnerabilities.all.forEach(vuln => {
        switch (vuln.severity?.toUpperCase()) {
            case 'CRITICAL':
                stats.critical++;
                break;
            case 'HIGH':
                stats.high++;
                break;
            case 'MEDIUM':
                stats.medium++;
                break;
            case 'LOW':
                stats.low++;
                break;
            default:
                stats.unknown++;
        }
    });

    if (vulnerabilities.byAsset) {
        stats.assetsAffected = Object.values(vulnerabilities.byAsset)
            .filter(vulns => vulns.length > 0).length;
    }

    return stats;
};

/**
 * Get vulnerability counts by asset
 */
export const getVulnCountsByAsset = (vulnerabilities) => {
    if (!vulnerabilities?.byAsset) return {};

    const counts = {};

    Object.entries(vulnerabilities.byAsset).forEach(([assetId, vulns]) => {
        counts[assetId] = {
            total: vulns.length,
            critical: vulns.filter(v => v.severity === 'CRITICAL').length,
            high: vulns.filter(v => v.severity === 'HIGH').length,
            medium: vulns.filter(v => v.severity === 'MEDIUM').length,
            low: vulns.filter(v => v.severity === 'LOW').length
        };
    });

    return counts;
};

/**
 * Clear all vulnerability caches (all time ranges)
 */
export const clearCache = () => {
    // Clear in-memory cache
    memoryCache.clear();

    // Clear all localStorage caches
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(CACHE_KEY_PREFIX)) {
            keysToRemove.push(key);
        }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
    console.log(`Cleared in-memory cache and ${keysToRemove.length} localStorage entries`);
};

export default {
    fetchAllVulnerabilities,
    fetchAssetVulnerabilities,
    getVulnerabilityStats,
    getVulnCountsByAsset,
    getDateRange,
    clearCache
};
